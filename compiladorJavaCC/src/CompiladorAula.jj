/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(CompiladorAula)
public class CompiladorAula{
    public static void main(final String[] args) throws ParseException  {    CompiladorAula parser = new CompiladorAula(System.in);    while (true)    {      System.out.println("Escreva um programa:");      try      {        switch (CompiladorAula.main())        {          case 0 :           System.out.println("Boa!!.");          break;          case 1 :           System.out.println("Terminou.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("Errou!.");        System.out.println(e.getMessage());        CompiladorAula.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(CompiladorAula)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : {  < INICIOPROGRAMA : "bora dar um piao" >| < PONTOVIRGULA : ";" >
| < VIRGULA : ",">| < ABREBLOCO : "{" >| < FIMBLOCO : "}" >
| < INTEIRO : "inteiro" >
| < ATRIBUICAO: "recebe" >
| < BOOLEANA: "teu cu" >
| < STRING: "desbaratinar uma ideia">
}TOKEN :{
 < NUMERO: (<DIGITO>)+ ( "." (<DIGITO>)+ )?>| < #DIGITO : [ "0"-"9" ] >
| < IF: "se pa" >
| < ELSE: "senao mete um migue">
| < FOR: "repete essa porra" >
| < TO: "ate" >
| < DO: "lanca ai">
| < TRUE: "true">
| < FALSE: "false" >
| < ID: ["a" - "z" , "A" - "Z"](["a" - "z" , "A" - "Z" , "0" - "9", "_"])*>
| < LETRA : ["A"-"Z"] | ["a"-"z"] >
| < PALAVRA: (< LETRA >)+>}
TOKEN : {	/*OPERADORES LÓGICOS*/

	< MAIOR: "eh maior" >
|	< MENOR: "eh menor" >
|	< MENOR_IGUAL: "eh menor ou igual" >
|	< MAIOR_IGUAL: "eh maior ou igual" >
|	< DIFERENTE: "eh diferente" >
|	< IGUAL: "eh gemeo" >
|   < AND : "&&" >
|   < OR: "||" >
}
int main() :{}{< INICIOPROGRAMA > < ABREBLOCO >

/* PODE OU NÃO TER CÓDIGO */
(comando())*

< FIMBLOCO >
{return 0;}}

void comando() : {} 
{
  	/* PODE SER:
  	 	DECLARAÇÃO DE VARIÁVEL
		CONDICIONAL
		UM DOS 2 LAÇOS DE REPETIÇÃO
  	 */


	/* aqui eu imaginei da gente inserir uma atribuição sem precisar da definição, mas não sei como verificariamos
  	 se a variável já foi definida anteriormente. na real não sei nem se isso é feito na análise léxica e sintática
  	  */
  	 < ID > atribuicao() | 
  	 declaracaoVariavel() |
  	 if_funcao()|
  	 for_funcao() |
  	 do_funcao()
}

void for_funcao(): { }
{
  < FOR > variavel_if() < TO > variavel_if() < ABREBLOCO >

	/* PODE OU NÃO TER VÁRIOS IF/FOR/DO ENCADEADO */
  (comando())*

  < FIMBLOCO >
}

void if_funcao(): { }
{
  < IF > expressao_logica() < ABREBLOCO >
	
	/* PODE OU NÃO TER VÁRIOS IF/FOR/DO ENCADEADO */
  (comando())*

  < FIMBLOCO >

  (< ELSE > < ABREBLOCO >

  /* PODE OU NÃO TER VÁRIOS IF/FOR/DO ENCADEADO */
  (comando())*

  < FIMBLOCO >)?
}


void do_funcao(): { }
{
  < DO > < ABREBLOCO >
  
	/* PODE OU NÃO TER VÁRIOS IF/FOR/DO ENCADEADO */
  (comando())*
  < FIMBLOCO >

  < TO > expressao_logica()
}

void expressao_logica() : {}
{
		(variavel_if() operador_logico() variavel_if())

			/* POSSIBILIDADE DE COLOCAR MAIS DE UMA CONDIÇÃO LÓGICA NO MESMO IF OU DO WHILE */

		( (< AND > | < OR >) expressao_logica())?
}

void variavel_if() : {} 
{
	      < ID >|< NUMERO >
	
}

void operador_logico() : {} 
{
		< MAIOR >
	|	< MENOR >
	|	< MENOR_IGUAL >
	|	< MAIOR_IGUAL >
	|	< DIFERENTE >
	|	< IGUAL >
}

void declaracaoVariavel():
{}
{
  tipoDado() identificador_variaveis() < PONTOVIRGULA >
}

void identificador_variaveis() : {} 
{
  		/* NOME VARIAVEL */
	  nomeVariavel()

		/* PODE OU NÃO TER ATRIBUIÇÃO */
	  (< ATRIBUICAO > (< ID > | < NUMERO > | < FALSE > | < TRUE >))?

		
	  /* PODE OU NÃO TER MAIS DE UMA VARIÁVEL DECLARADA */
	  (declararMais())?
}

void declararMais(): { }
{

	/* - aqui o token em comum sempre vai ser a vírgula seguida do nome da variável, o que pode ou não ter depois disso
	   é a atribuição, por isso o ? nela.

	   - Esse processo pode se repetir 1x ou mais
	 */
  
  (< VIRGULA > (nomeVariavel() (atribuicao())?))+
}

void nomeVariavel(): { }
{
	(< ID > | < LETRA >)
}

void atribuicao(): { }
{
  (< ATRIBUICAO > (< ID > | < NUMERO > | < FALSE > | < TRUE > | < PALAVRA >))
}

void tipoDado(): { }
{
  < INTEIRO >|< BOOLEANA >|< STRING >
}